Plugin for supporting release dependencies. It\textquotesingle{}s rare for an embedded project to be built completely free of other libraries and modules. Some of these may be standard internal libraries. Some of these may be 3rd party libraries. In either case, they become part of the project\textquotesingle{}s ecosystem.

This plugin is intended to make that relationship easier. It allows you to specify a source for dependencies. If required, it will automatically grab the appropriate version of that dependency.

Most 3rd party libraries have a method of building already in place. While we\textquotesingle{}d love to convert the world to a place where everything downloads with a test suite in Ceedling, that\textquotesingle{}s not likely to happen anytime soon. Until then, this plugin will allow the developer to specify what calls Ceedling should make to oversee the build process of those third party utilities. Are they using Make? C\+Make? A custom series of scripts that only a mad scientist could possibly understand? No matter. Ceedling has you covered. Just specify what should be called, and Ceedling will make it happen whenever it notices that the output artifacts are missing.

Output artifacts? Sure! Things like static and dynamic libraries, or folders containing header files that might want to be included by your release project.

So how does all this magic work?

First, you need to add the {\ttfamily \+:dependencies} plugin to your list. Then, we\textquotesingle{}ll add a new section called \+:dependencies. There, you can list as many dependencies as you desire. Each has a series of fields which help Ceedling to understand your needs. Many of them are optional. If you don\textquotesingle{}t need that feature, just don\textquotesingle{}t include it! In the end, it\textquotesingle{}ll look something like this\+:


\begin{DoxyCode}
:dependencies:
  :libraries:
    - :name: WolfSSL
      :source\_path:   third\_party/wolfssl/source
      :build\_path:    third\_party/wolfssl/build
      :artifact\_path: third\_party/wolfssl/install
      :fetch:
        :method: :zip
        :source: \(\backslash\)\(\backslash\)shared\_drive\(\backslash\)third\_party\_libs\(\backslash\)wolfssl\(\backslash\)wolfssl-4.2.0.zip
      :environment:
        - CFLAGS+=-DWOLFSSL\_DTLS\_ALLOW\_FUTURE
      :build:
        - "autoreconf -i"
        - "./configure --enable-tls13 --enable-singlethreaded"
        - make
        - make install
      :artifacts:
        :static\_libraries:
          - lib/wolfssl.a
        :dynamic\_libraries:
          - lib/wolfssl.so
        :includes:
          - include/**
\end{DoxyCode}


Let\textquotesingle{}s take a deeper look at each of these features.

\subsection*{The Starting Dash \& Name }

Yes, that opening dash tells the dependencies plugin that the rest of these fields belong to our first dependency. If we had a second dependency, we\textquotesingle{}d have another dash, lined up with the first, and followed by all the fields indented again.

By convention, we use the {\ttfamily \+:name} field as the first field for each tool. Ceedling honestly doesn\textquotesingle{}t care which order the fields are given... but as humans, it makes it easier for us to see the name of each dependency with starting dash.

The name field is only used to print progress while we\textquotesingle{}re running Ceedling. You may call the name of the field whatever you wish.

\subsection*{Working Folders }

The {\ttfamily \+:source\+\_\+path} field allows us to specify where the source code for each of our dependencies is stored. If fetching the dependency from elsewhere, it will be fetched to this location. All commands to build this dependency will be executed from this location (override this by specifying a {\ttfamily \+:build\+\_\+path}). Finally, the output artifacts will be referenced to this location (override this by specifying a {\ttfamily \+:artifact\+\_\+path})

If unspecified, the {\ttfamily \+:source\+\_\+path} will be {\ttfamily dependencies\textbackslash{}dep\+\_\+name} where {\ttfamily dep\+\_\+name} is the name specified in {\ttfamily \+:name} above (with special characters removed). It\textquotesingle{}s best, though, if you specify exactly where you want your dependencies to live.

If the dependency is directly included in your project (you\textquotesingle{}ve specified {\ttfamily \+:none} as the {\ttfamily \+:method} for fetching), then {\ttfamily \+:source\+\_\+path} should be where your Ceedling can find the source for your dependency in you repo.

All artifacts are relative to the {\ttfamily \+:artifact\+\_\+path} (which defaults to be the same as {\ttfamily \+:source\+\_\+path})

\subsection*{Fetching Dependencies }

The {\ttfamily \+:dependencies} plugin supports the ability to automatically fetch your dependencies for you... using some common methods of fetching source. This section contains only a couple of fields\+:


\begin{DoxyItemize}
\item {\ttfamily \+:method} -- This is the method that this dependency is fetched.
\begin{DoxyItemize}
\item {\ttfamily \+:none} -- This tells Ceedling that the code is already included in the project.
\item {\ttfamily \+:zip} -- This tells Ceedling that we want to unpack a zip file to our source path.
\item {\ttfamily \+:git} -- This tells Ceedling that we want to clone a git repo to our source path.
\item {\ttfamily \+:svn} -- This tells Ceedling that we want to checkout a subversion repo to our source path.
\item {\ttfamily \+:custom} -- This tells Ceedling that we want to use a custom command or commands to fetch the code.
\end{DoxyItemize}
\item {\ttfamily \+:source} -- This is the path or url to fetch code when using the zip or git method.
\item {\ttfamily \+:tag}/{\ttfamily \+:branch} -- This is the specific tag or branch that you wish to retrieve (git only. optional).
\item {\ttfamily \+:hash} -- This is the specific S\+H\+A1 hash you want to fetch (git only. optional, requires a deep clone).
\item {\ttfamily \+:revision} -- This is the specific revision you want to fetch (svn only. optional).
\item {\ttfamily \+:executable} -- This is a list of commands to execute when using the {\ttfamily \+:custom} method
\end{DoxyItemize}

\subsection*{Environment Variables }

Many build systems support customization through environment variables. By specifying an array of environment variables, Ceedling will customize the shell environment before calling the build process.

Environment variables may be specified in three ways. Let\textquotesingle{}s look at one of each\+:


\begin{DoxyCode}
:environment:
  - ARCHITECTURE=ARM9
  - CFLAGS+=-DADD\_AWESOMENESS
  - CFLAGS-=-DWASTE
\end{DoxyCode}


In the first example, you see the most straightforward method. The environment variable {\ttfamily A\+R\+C\+H\+I\+T\+E\+C\+T\+U\+RE} is set to the value {\ttfamily A\+R\+M9}. That\textquotesingle{}s it. Simple.

The next two options modify an existing symbol. In the first one, we use {\ttfamily +=}, which tells Ceedling to add the define {\ttfamily A\+D\+D\+\_\+\+A\+W\+E\+S\+O\+M\+E\+N\+E\+SS} to the environment variable {\ttfamily C\+F\+L\+A\+GS}. The second tells Ceedling to remove the define {\ttfamily W\+A\+S\+TE} from the same environment variable.

There are a couple of things to note here.

First, when adding to a variable, Ceedling has no way of knowing what delimiter you are expecting. In this example you can see we manually added some whitespace. If we had been modifying {\ttfamily P\+A\+TH} instead, we might have had to use a {\ttfamily \+:} on a unux or {\ttfamily ;} on Windows.

Second, removing an argument will have no effect on the argument if that argument isn\textquotesingle{}t found precisely. It\textquotesingle{}s case sensitive and the entire string must match. If symbol doesn\textquotesingle{}t already exist, it W\+I\+LL after executing this command... however it will be assigned to nothing.

\subsection*{Building Dependencies }

The heart of the {\ttfamily \+:dependencies} plugin is the ability for you, the developer, to specify the build process for each of your dependencies. You will need to have any required tools installed before using this feature.

The steps are specified as an array of strings. Ceedling will execute those steps in the order specified, moving from step to step unless an error is encountered. By the end of the process, the artifacts should have been created by your process... otherwise an error will be produced.

\subsection*{Artifacts }

These are the outputs of the build process. There are there types of artifacts. Any dependency may have none or some of these. Calling out these files tells Ceedling that they are important. Your dependency\textquotesingle{}s build process may produce many other files... but these are the files that Ceedling understands it needs to act on.

\subsubsection*{{\ttfamily static\+\_\+libraries}}

Specifying one or more static libraries will tell Ceedling where it should find static libraries output by your build process. These libraries are automatically added to the list of dependencies and will be linked with the rest of your code to produce the final release.

If any of these libraries don\textquotesingle{}t exist, Ceedling will trigger your build process in order for it to produce them.

\subsubsection*{{\ttfamily dynamic\+\_\+libraries}}

Specifying one or more dynamic libraries will tell Ceedling where it should find dynamic libraries output by your build process. These libraries are automatically copied to the same folder as your final release binary.

If any of these libraries don\textquotesingle{}t exist, Ceedling will trigger your build process in order for it to produce them.

\subsubsection*{{\ttfamily includes}}

Often when libraries are built, the same process will output a collection of includes so that your release code knows how to interact with that library. It\textquotesingle{}s the public A\+PI for that library. By specifying the directories that will contain these includes (don\textquotesingle{}t specify the files themselves, Ceedling only needs the directories), Ceedling is able to automatically add these to its internal include list. This allows these files to be used while building your release code, as well we making them mockable during unit testing.

\subsubsection*{{\ttfamily source}}

It\textquotesingle{}s possible that your external dependency will just produce additional C files as its output. In this case, Ceedling is able to automatically add these to its internal source list. This allows these files to be used while building your release code.

\subsection*{Tasks }

Once configured correctly, the {\ttfamily \+:dependencies} plugin should integrate seamlessly into your workflow and you shouldn\textquotesingle{}t have to think about it. In the real world, that doesn\textquotesingle{}t always happen. Here are a number of tasks that are added or modified by this plugin.

\subsubsection*{{\ttfamily ceedling dependencies\+:clean}}

This can be issued in order to completely remove the dependency from its source path. On the next build, it will be refetched and rebuilt from scratch. This can also apply to a particular dependency. For example, by specifying {\ttfamily dependencies\+:clean\+:Dep\+Name}.

\subsubsection*{{\ttfamily ceedling dependencies\+:fetch}}

This can be issued in order to fetch each dependency from its origin. This will have no effect on dependencies that don\textquotesingle{}t have fetch instructions specified. This can also apply to a particular dependency. For example, by specifying {\ttfamily dependencies\+:fetch\+:Dep\+Name}.

\subsubsection*{{\ttfamily ceedling dependencies\+:make}}

This will force the dependencies to all build. This should happen automatically when a release has been triggered... but if you\textquotesingle{}re just getting your dependency configured at this moment, you may want to just use this feature instead. A single dependency can also be built by specifying its name, like {\ttfamily dependencies\+:make\+:My\+Tuna\+Boat}.

\subsubsection*{{\ttfamily ceedling dependencies\+:deploy}}

This will force any dynamic libraries produced by your dependencies to be copied to your release build directory... just in case you clobbered them.

\subsubsection*{{\ttfamily paths\+:include}}

Maybe you want to verify that all the include paths are correct. If you query Ceedling with this request, it will list all the header file paths that it\textquotesingle{}s found, including those produced by dependencies.

\subsubsection*{{\ttfamily files\+:include}}

Maybe you want to take that query further and actually get a list of A\+LL the header files Ceedling has found, including those belonging to your dependencies.

\section*{Testing }

Hopefully all your dependencies are fully tested... but we can\textquotesingle{}t always depend on that. In the event that they are tested with Ceedling, you\textquotesingle{}ll probably want to consider using the {\ttfamily \+:subprojects} plugin instead of this one. The purpose of this plugin is to pull in third party code for release... and to provide a mockable interface for Ceedling to use during its tests of other modules.

If that\textquotesingle{}s what you\textquotesingle{}re after... you\textquotesingle{}ve found the right plugin!

Happy Testing! 