\hypertarget{group__x_semaphore_create_mutex}{}\section{x\+Semaphore\+Create\+Mutex}
\label{group__x_semaphore_create_mutex}\index{x\+Semaphore\+Create\+Mutex@{x\+Semaphore\+Create\+Mutex}}
semphr. h 
\begin{DoxyPre}
SemaphoreHandle\_t \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex( void )};
\end{DoxyPre}


Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.

Internally, within the Free\+R\+T\+OS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{x\+Semaphore\+Create\+Mutex()} then the required memory is automatically dynamically allocated inside the \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{x\+Semaphore\+Create\+Mutex()} function. (see \href{https://www.FreeRTOS.org/a00111.html}{\tt https\+://www.\+Free\+R\+T\+O\+S.\+org/a00111.\+html}). If a mutex is created using x\+Semaphore\+Create\+Mutex\+Static() then the application writer must provided the memory. x\+Semaphore\+Create\+Mutex\+Static() therefore allows a mutex to be created without using any dynamic memory allocation.

Mutexes created using this function can be accessed using the \hyperlink{externals_2freertos_2include_2semphr_8h_af116e436d2a5ae5bd72dbade2b5ea930}{x\+Semaphore\+Take()} and \hyperlink{externals_2freertos_2include_2semphr_8h_aae55761cabfa9bf85c8f4430f78c0953}{x\+Semaphore\+Give()} macros. The \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_ad395f4bba51eea6af3397d72bc079e4d}{x\+Semaphore\+Take\+Recursive()} and \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_a398d66b17856c22dd49d39aaac42f105}{x\+Semaphore\+Give\+Recursive()} macros must not be used.

This type of semaphore uses a priority inheritance mechanism so a task \textquotesingle{}taking\textquotesingle{} a semaphore M\+U\+ST A\+L\+W\+A\+YS \textquotesingle{}give\textquotesingle{} the semaphore back once the semaphore it is no longer required.

Mutex type semaphores cannot be used from within interrupt service routines.

See \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_acba963695e4f159d9bfa2394cae5badc}{x\+Semaphore\+Create\+Binary()} for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always \textquotesingle{}gives\textquotesingle{} the semaphore and another always \textquotesingle{}takes\textquotesingle{} the semaphore) and from within interrupt service routines.

\begin{DoxyReturn}{Returns}
If the mutex was successfully created then a handle to the created semaphore is returned. If there was not enough heap to allocate the mutex data structures then N\+U\+LL is returned.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
SemaphoreHandle\_t xSemaphore;\end{DoxyPre}



\begin{DoxyPre}void vATask( void * pvParameters )
\{
 // Semaphore cannot be used before a call to \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex()}.
 // This is a macro so pass the variable in directly.
 xSemaphore = \hyperlink{vendor_2ceedling_2plugins_2freertos_2src_2freertos_2include_2semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex()};\end{DoxyPre}



\begin{DoxyPre} if( xSemaphore != NULL )
 \{
     // The semaphore was created successfully.
     // The semaphore can now be used.
 \}
\}
\end{DoxyPre}
 